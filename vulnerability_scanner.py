import requests
import ssl
import socket
import urllib.parse
import re
import logging
from datetime import datetime
import concurrent.futures
import time
from ai_vulnerability_analyzer import AIVulnerabilityAnalyzer

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    """Alternative vulnerability scanner using various security checks"""
    
    def __init__(self):
        self.timeout = 10
        self.user_agent = 'VortiqX-Security-Scanner/1.0'
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': self.user_agent})
        self.ai_analyzer = AIVulnerabilityAnalyzer()
        
    def scan_url(self, target_url):
        """
        Perform a comprehensive security scan on the target URL
        
        Args:
            target_url (str): The URL to scan
            
        Returns:
            list: List of security alerts found
        """
        try:
            logger.info(f"Starting vulnerability scan for: {target_url}")
            
            parsed_url = urllib.parse.urlparse(target_url)
            hostname = parsed_url.hostname
            port = parsed_url.port or (443 if parsed_url.scheme == 'https' else 80)
            
            alerts = []
            
            # Get initial page response for AI analysis
            try:
                response = self.session.get(target_url, timeout=self.timeout)
                page_content = response.text
                page_headers = response.headers
            except Exception as e:
                logger.warning(f"Could not fetch page content for AI analysis: {str(e)}")
                page_content = ""
                page_headers = {}
            
            # Run various security checks
            with concurrent.futures.ThreadPoolExecutor(max_workers=6) as executor:
                futures = {
                    executor.submit(self.check_ssl_security, hostname, port): 'SSL Security',
                    executor.submit(self.check_http_headers, target_url): 'HTTP Headers',
                    executor.submit(self.check_common_vulnerabilities, target_url): 'Common Vulnerabilities',
                    executor.submit(self.check_directory_traversal, target_url): 'Directory Traversal',
                    executor.submit(self.check_xss_protection, target_url): 'XSS Protection',
                    executor.submit(self.ai_analyzer.analyze_response_content, target_url, page_content, page_headers): 'AI Analysis'
                }
                
                for future in concurrent.futures.as_completed(futures):
                    check_type = futures[future]
                    try:
                        result = future.result()
                        if result:
                            alerts.extend(result)
                    except Exception as e:
                        logger.error(f"Error in {check_type} check: {str(e)}")
            
            logger.info(f"Scan completed for {target_url}. Found {len(alerts)} issues.")
            return alerts
            
        except Exception as e:
            logger.error(f"Error during scan: {str(e)}")
            return None
    
    def check_ssl_security(self, hostname, port):
        """Check SSL/TLS security configuration"""
        alerts = []
        
        try:
            if port != 443:
                return alerts
                
            # Check SSL certificate
            context = ssl.create_default_context()
            sock = socket.create_connection((hostname, port), timeout=self.timeout)
            ssock = context.wrap_socket(sock, server_hostname=hostname)
            
            cert = ssock.getpeercert()
            
            # Check certificate expiry
            if cert and 'notAfter' in cert:
                not_after = datetime.strptime(str(cert['notAfter']), '%b %d %H:%M:%S %Y %Z')
                days_until_expiry = (not_after - datetime.now()).days
                
                if days_until_expiry < 30:
                    alerts.append({
                        'alert': 'SSL Certificate Expiring Soon',
                        'risk': 'Medium',
                        'confidence': 'High',
                        'description': f'SSL certificate expires in {days_until_expiry} days',
                        'solution': 'Renew the SSL certificate before it expires',
                        'url': f'https://{hostname}',
                        'param': '',
                        'evidence': f'Expires: {cert["notAfter"]}',
                        'cweid': '295',
                        'wascid': '4'
                    })
            
            # Check for weak cipher suites
            cipher = ssock.cipher()
            if cipher and cipher[0] and ('RC4' in cipher[0] or 'DES' in cipher[0]):
                alerts.append({
                    'alert': 'Weak SSL Cipher Suite',
                    'risk': 'Medium',
                    'confidence': 'High',
                    'description': 'Server supports weak cipher suites',
                    'solution': 'Configure server to use strong cipher suites only',
                    'url': f'https://{hostname}',
                    'param': '',
                    'evidence': f'Cipher: {cipher[0] if cipher else "Unknown"}',
                    'cweid': '326',
                    'wascid': '4'
                })
            
            ssock.close()
            
        except ssl.SSLError as e:
            alerts.append({
                'alert': 'SSL Configuration Issue',
                'risk': 'High',
                'confidence': 'High',
                'description': f'SSL/TLS configuration problem: {str(e)}',
                'solution': 'Fix SSL/TLS configuration on the server',
                'url': f'https://{hostname}',
                'param': '',
                'evidence': str(e),
                'cweid': '295',
                'wascid': '4'
            })
        except Exception as e:
            logger.debug(f"SSL check failed: {str(e)}")
            
        return alerts
    
    def check_http_headers(self, url):
        """Check for missing security headers"""
        alerts = []
        
        try:
            response = self.session.get(url, timeout=self.timeout, allow_redirects=True)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                'X-Content-Type-Options': {
                    'expected': 'nosniff',
                    'risk': 'Low',
                    'description': 'Missing X-Content-Type-Options header allows MIME type sniffing',
                    'solution': 'Add X-Content-Type-Options: nosniff header'
                },
                'X-Frame-Options': {
                    'expected': ['DENY', 'SAMEORIGIN'],
                    'risk': 'Medium',
                    'description': 'Missing X-Frame-Options header allows clickjacking attacks',
                    'solution': 'Add X-Frame-Options: DENY or SAMEORIGIN header'
                },
                'X-XSS-Protection': {
                    'expected': '1; mode=block',
                    'risk': 'Low',
                    'description': 'Missing X-XSS-Protection header',
                    'solution': 'Add X-XSS-Protection: 1; mode=block header'
                },
                'Strict-Transport-Security': {
                    'expected': None,
                    'risk': 'Medium',
                    'description': 'Missing HSTS header allows protocol downgrade attacks',
                    'solution': 'Add Strict-Transport-Security header for HTTPS sites'
                },
                'Content-Security-Policy': {
                    'expected': None,
                    'risk': 'Medium',
                    'description': 'Missing Content Security Policy header',
                    'solution': 'Implement a Content Security Policy to prevent XSS attacks'
                }
            }
            
            for header, config in security_headers.items():
                if header not in headers:
                    alerts.append({
                        'alert': f'Missing Security Header: {header}',
                        'risk': config['risk'],
                        'confidence': 'High',
                        'description': config['description'],
                        'solution': config['solution'],
                        'url': url,
                        'param': header,
                        'evidence': f'Header "{header}" not found',
                        'cweid': '16',
                        'wascid': '15'
                    })
            
            # Check for information disclosure in headers
            disclosure_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in disclosure_headers:
                if header in headers:
                    alerts.append({
                        'alert': 'Information Disclosure in HTTP Headers',
                        'risk': 'Low',
                        'confidence': 'Medium',
                        'description': f'Server reveals technology information in {header} header',
                        'solution': f'Remove or obfuscate the {header} header',
                        'url': url,
                        'param': header,
                        'evidence': f'{header}: {headers[header]}',
                        'cweid': '200',
                        'wascid': '13'
                    })
                    
        except Exception as e:
            logger.debug(f"HTTP headers check failed: {str(e)}")
            
        return alerts
    
    def check_common_vulnerabilities(self, url):
        """Check for common web vulnerabilities"""
        alerts = []
        
        try:
            # Check for directory listing
            test_urls = [
                url.rstrip('/') + '/',
                url.rstrip('/') + '/admin/',
                url.rstrip('/') + '/backup/',
                url.rstrip('/') + '/test/'
            ]
            
            for test_url in test_urls:
                try:
                    response = self.session.get(test_url, timeout=self.timeout)
                    if response.status_code == 200:
                        if 'Index of' in response.text or 'Directory Listing' in response.text:
                            alerts.append({
                                'alert': 'Directory Listing Enabled',
                                'risk': 'Medium',
                                'confidence': 'High',
                                'description': 'Directory listing is enabled, exposing file structure',
                                'solution': 'Disable directory listing on the web server',
                                'url': test_url,
                                'param': '',
                                'evidence': 'Directory listing detected in response',
                                'cweid': '548',
                                'wascid': '48'
                            })
                except:
                    continue
            
            # Check for common sensitive files
            sensitive_files = [
                '/robots.txt',
                '/.htaccess',
                '/web.config',
                '/phpinfo.php',
                '/admin.php',
                '/login.php',
                '/.env',
                '/config.php'
            ]
            
            base_url = f"{urllib.parse.urlparse(url).scheme}://{urllib.parse.urlparse(url).netloc}"
            
            for file_path in sensitive_files:
                try:
                    test_url = base_url + file_path
                    response = self.session.get(test_url, timeout=self.timeout)
                    if response.status_code == 200 and len(response.text) > 0:
                        alerts.append({
                            'alert': 'Sensitive File Exposed',
                            'risk': 'Medium',
                            'confidence': 'High',
                            'description': f'Sensitive file {file_path} is publicly accessible',
                            'solution': 'Restrict access to sensitive files or remove them',
                            'url': test_url,
                            'param': '',
                            'evidence': f'File accessible at {file_path}',
                            'cweid': '200',
                            'wascid': '34'
                        })
                except:
                    continue
                    
        except Exception as e:
            logger.debug(f"Common vulnerabilities check failed: {str(e)}")
            
        return alerts
    
    def check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        alerts = []
        
        try:
            # Test for directory traversal
            traversal_payloads = [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                '../../../../../../../etc/passwd%00',
                '....//....//....//etc/passwd'
            ]
            
            for payload in traversal_payloads:
                test_url = f"{url}{'&' if '?' in url else '?'}file={payload}"
                try:
                    response = self.session.get(test_url, timeout=self.timeout)
                    if 'root:' in response.text or 'localhost' in response.text:
                        alerts.append({
                            'alert': 'Directory Traversal Vulnerability',
                            'risk': 'High',
                            'confidence': 'Medium',
                            'description': 'Application appears vulnerable to directory traversal attacks',
                            'solution': 'Implement proper input validation and file access controls',
                            'url': test_url,
                            'param': 'file',
                            'evidence': 'System file content detected in response',
                            'cweid': '22',
                            'wascid': '33'
                        })
                        break
                except:
                    continue
                    
        except Exception as e:
            logger.debug(f"Directory traversal check failed: {str(e)}")
            
        return alerts
    
    def check_xss_protection(self, url):
        """Check for XSS protection mechanisms"""
        alerts = []
        
        try:
            # Test for reflected XSS
            xss_payload = '<script>alert("XSS")</script>'
            test_url = f"{url}{'&' if '?' in url else '?'}test={xss_payload}"
            
            response = self.session.get(test_url, timeout=self.timeout)
            if xss_payload in response.text:
                alerts.append({
                    'alert': 'Potential XSS Vulnerability',
                    'risk': 'High',
                    'confidence': 'Low',
                    'description': 'Application may be vulnerable to Cross-Site Scripting (XSS)',
                    'solution': 'Implement proper input validation and output encoding',
                    'url': test_url,
                    'param': 'test',
                    'evidence': 'Unfiltered script tag detected in response',
                    'cweid': '79',
                    'wascid': '8'
                })
                
        except Exception as e:
            logger.debug(f"XSS protection check failed: {str(e)}")
            
        return alerts